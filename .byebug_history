continue
column
row
continue
column
row
exit
matrix
continue
exit
matrix
continue
column
row
exit
children(1)
store
continue
store
continue
exit
continue
p 'true' if swap
swap
      end
        debugger
        current_idx = lowest_index
        @store[current_idx], @store[lowest_index] = @store[lowest_index], @store[current_idx]
if swap
if swap p "n" end
if swap
swap
continue
exit
continue
@store[child_idx].value
@store[child_index].value
@store[lowest_index].value
swap
continue
@store[lowest_index].value
@store[child_idx].value
child_idx
children_idx
exit
exoit
continue
exit
continue
current_idx
continue
exit
continue
children_idx
lowest_index
exit
store[1]
children(0)
@store
exit
store
exit
store
continue
store
continue
store
continue
store
continue
store
exit
@store
exit()
@store[0]
@store.length
@store
exit
min_heap.peek
min_heap
continue
number
continue
number
max_heap
min_heap
continue
max_heap
min_heap
number
continue
exit
max_heap
min_heap
number
median
continue
number
continue
exit
number
continue
median
max_heap
min_heap
number
continue
median
max_heap
min_heap
min_heapo
number
continue
median
max_heap
min_heap
number
